const express = require('express');
const cors = require('cors');
const path = require('path');
const fs = require('fs').promises;
const archiver = require('archiver');
const dotenv = require('dotenv');

// Dynamic import for the core package
let Client;
(async () => {
    try {
        const coreModule = await import('@pluggy-ofx-export/core');
        Client = coreModule.Client;
    } catch (error) {
        console.error('Error loading core package:', error);
    }
})();

const app = express();
const PORT = process.env.PORT || 3001;

// Middleware
app.use(cors());
app.use(express.json({ limit: '50mb' })); // Increase body size limit for ZIP files
app.use(express.static(path.join(__dirname)));

// Global variables for credentials
let client = null;
let credentials = null;
let customAccountNames = {}; // Store custom names: { accountId: customName }

// Load credentials from environment
async function loadCredentials() {
    try {
        const clientId = process.env.PLUGGY_CLIENT_ID;
        const clientSecret = process.env.PLUGGY_CLIENT_SECRET;
        const itemIds = process.env.PLUGGY_ITEM_IDS;
        const customNames = process.env.PLUGGY_CUSTOM_NAMES;

        if (clientId && clientSecret && itemIds) {
            credentials = {
                clientId,
                clientSecret,
                itemIds: itemIds.split(',').map(id => id.trim())
            };
            client = new Client(credentials);
            
            // Load custom account names if they exist
            if (customNames) {
                try {
                    customAccountNames = JSON.parse(customNames);
                    console.log('✅ Custom account names loaded from environment');
                } catch (parseError) {
                    console.log('⚠️ Could not parse custom account names, using defaults');
                    customAccountNames = {};
                }
            }
            
            console.log('✅ Credentials loaded from environment');
            return true;
        }
        return false;
    } catch (error) {
        console.error('Error loading credentials:', error);
        return false;
    }
}

// Initialize credentials on startup
loadCredentials();

// Helper function to save credentials and custom names to .env file
async function saveToEnvFile() {
    const envPath = path.join(__dirname, '..', '.env');
    const envContent = `# Pluggy API Configuration
# Generated by web interface on ${new Date().toISOString()}
PLUGGY_CLIENT_ID=${credentials.clientId}
PLUGGY_CLIENT_SECRET=${credentials.clientSecret}
PLUGGY_ITEM_IDS=${credentials.itemIds.join(',')}
PLUGGY_CUSTOM_NAMES=${JSON.stringify(customAccountNames)}

# Instructions:
# 1. This file was created by the web interface
# 2. Get your credentials from https://dashboard.pluggy.ai/
# 3. Never commit this file to version control
# 4. Custom account names are stored in PLUGGY_CUSTOM_NAMES as JSON
`;

    try {
        await fs.writeFile(envPath, envContent, 'utf8');
        console.log('✅ Configuration saved to .env file');
        return true;
    } catch (writeError) {
        console.error('Warning: Could not write to .env file:', writeError.message);
        return false;
    }
}

// API Routes

// Check if credentials exist
app.get('/api/credentials', async (req, res) => {
    // Check if .env file exists and reload if needed
    const envPath = path.join(__dirname, '..', '.env');
    try {
        const envExists = await fs.access(envPath).then(() => true).catch(() => false);
        if (envExists && !credentials) {
            // Reload environment variables from .env file
            require('dotenv').config({ path: envPath });
            await loadCredentials();
        }
    } catch (error) {
        // Ignore errors, just use current state
    }

    res.json({
        hasCredentials: credentials !== null,
        hasClientId: !!process.env.PLUGGY_CLIENT_ID,
        hasClientSecret: !!process.env.PLUGGY_CLIENT_SECRET,
        hasItemIds: !!process.env.PLUGGY_ITEM_IDS
    });
});

// Save credentials (for web interface)
app.post('/api/credentials', async (req, res) => {
    try {
        const { clientId, clientSecret, itemIds } = req.body;

        if (!clientId || !clientSecret || !itemIds) {
            return res.status(400).json({
                success: false,
                message: 'All credential fields are required'
            });
        }

        // Update credentials in memory
        credentials = {
            clientId,
            clientSecret,
            itemIds: itemIds.split(',').map(id => id.trim())
        };
        client = new Client(credentials);

        // Save credentials to .env file
        await saveToEnvFile();

        res.json({
            success: true,
            message: 'Credentials saved successfully to .env file'
        });
    } catch (error) {
        console.error('Error saving credentials:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to save credentials'
        });
    }
});

// Add more item IDs to existing credentials
app.post('/api/credentials/add-items', async (req, res) => {
    try {
        const { newItemIds } = req.body;

        if (!newItemIds) {
            return res.status(400).json({
                success: false,
                message: 'No item IDs provided'
            });
        }

        if (!credentials) {
            return res.status(400).json({
                success: false,
                message: 'No credentials available. Please save credentials first.'
            });
        }

        // Parse new item IDs
        const newIds = newItemIds.split(',').map(id => id.trim()).filter(id => id);
        
        if (newIds.length === 0) {
            return res.status(400).json({
                success: false,
                message: 'No valid item IDs provided'
            });
        }

        // Add new item IDs to existing ones
        const existingIds = credentials.itemIds || [];
        const allIds = [...new Set([...existingIds, ...newIds])]; // Remove duplicates

        // Update credentials in memory
        credentials.itemIds = allIds;
        client = new Client(credentials);

        // Update .env file
        await saveToEnvFile();

        res.json({
            success: true,
            message: `Added ${newIds.length} new item IDs. Total: ${allIds.length} item IDs.`
        });
    } catch (error) {
        console.error('Error adding item IDs:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to add item IDs'
        });
    }
});

// Get custom account names
app.get('/api/account-names', async (req, res) => {
    try {
        res.json({
            success: true,
            customNames: customAccountNames
        });
    } catch (error) {
        console.error('Error fetching custom names:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch custom names'
        });
    }
});

// Save custom account name
app.post('/api/account-names', async (req, res) => {
    try {
        const { accountId, customName } = req.body;

        if (!accountId) {
            return res.status(400).json({
                success: false,
                message: 'Account ID is required'
            });
        }

        if (!customName || customName.trim() === '') {
            // Remove custom name if empty
            delete customAccountNames[accountId];
        } else {
            // Save custom name
            customAccountNames[accountId] = customName.trim();
        }

        // Save to .env file
        await saveToEnvFile();

        res.json({
            success: true,
            message: customName ? 'Custom name saved successfully' : 'Custom name removed successfully'
        });
    } catch (error) {
        console.error('Error saving custom name:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to save custom name'
        });
    }
});

// Get available accounts
app.get('/api/accounts', async (req, res) => {
    try {
        if (!client) {
            return res.status(400).json({
                success: false,
                message: 'No credentials available. Please configure your API credentials first.'
            });
        }

        const allAccounts = [];
        
        // Fetch accounts for each item ID
        for (const itemId of credentials.itemIds) {
            try {
                const accountsResponse = await client.client.fetchAccounts(itemId);
                const accounts = accountsResponse.results.map(account => ({
                    id: account.id,
                    name: account.name,
                    customName: customAccountNames[account.id] || null,
                    displayName: customAccountNames[account.id] || account.name,
                    type: account.type,
                    balance: account.balance,
                    currencyCode: account.currencyCode,
                    number: account.number,
                    bankInfo: {
                        orgName: account.bankData?.transferNumber ? 
                            account.bankData.transferNumber.split('/')[0] : 
                            account.name
                    }
                }));
                allAccounts.push(...accounts);
            } catch (error) {
                console.error(`Error fetching accounts for item ${itemId}:`, error);
                // Continue with other items
            }
        }

        res.json({
            success: true,
            accounts: allAccounts
        });
    } catch (error) {
        console.error('Error fetching accounts:', error);
        res.status(500).json({
            success: false,
            message: 'Failed to fetch accounts. Please check your credentials and try again.'
        });
    }
});

// Export OFX files
app.post('/api/export', async (req, res) => {
    try {
        if (!client) {
            return res.status(400).json({
                success: false,
                message: 'No credentials available'
            });
        }

        const { accountIds, startDate, endDate, prefix, suffix } = req.body;

        if (!accountIds || accountIds.length === 0) {
            return res.status(400).json({
                success: false,
                message: 'No accounts selected'
            });
        }

        if (!startDate || !endDate) {
            return res.status(400).json({
                success: false,
                message: 'Invalid date range'
            });
        }

        // Generate files in memory for download

        const dateStart = new Date(startDate);
        const dateEnd = new Date(endDate);
        const generatedFiles = [];

        // Get all accounts to find the ones we need to export
        const allAccounts = [];
        for (const itemId of credentials.itemIds) {
            try {
                const accountsResponse = await client.client.fetchAccounts(itemId);
                allAccounts.push(...accountsResponse.results);
            } catch (error) {
                console.error(`Error fetching accounts for item ${itemId}:`, error);
            }
        }

        // Filter to selected accounts
        const selectedAccounts = allAccounts.filter(acc => accountIds.includes(acc.id));

        // Group accounts by item ID for efficient processing
        const accountsByItem = {};
        selectedAccounts.forEach(account => {
            // Find which item ID this account belongs to
            for (const itemId of credentials.itemIds) {
                // We'll need to check this by trying to fetch accounts for each item
                // For now, we'll process each account individually
                if (!accountsByItem[itemId]) {
                    accountsByItem[itemId] = [];
                }
            }
        });

        // Process each selected account
        for (const account of selectedAccounts) {
            try {
                console.log(`Processing account: ${account.name} (${account.id})`);
                
                // Find the item ID for this account
                let accountItemId = null;
                for (const itemId of credentials.itemIds) {
                    try {
                        const accountsResponse = await client.client.fetchAccounts(itemId);
                        if (accountsResponse.results.some(acc => acc.id === account.id)) {
                            accountItemId = itemId;
                            break;
                        }
                    } catch (error) {
                        console.log(`Error checking item ${itemId} for account ${account.id}:`, error.message);
                        // Continue checking other item IDs
                    }
                }

                if (!accountItemId) {
                    console.error(`Could not find item ID for account ${account.id} (${account.name})`);
                    continue;
                }

                console.log(`Found item ID ${accountItemId} for account ${account.name}`);

                // Generate OFX files for this account
                console.log(`Generating OFX files for account ${account.name}...`);
                const ofxFiles = await client.outputOFXFiles(accountItemId, dateStart, dateEnd);
                console.log(`Generated ${ofxFiles.length} OFX files for account ${account.name}`);
                
                // Filter to only the files for the selected account
                const accountFiles = ofxFiles.filter(file => {
                    // This is a bit tricky - we need to match the account
                    // For now, we'll process all files and let the user handle duplicates
                    return true;
                });

                // Save each OFX file
                for (const ofxFile of accountFiles) {
                    let fileName = ofxFile.getSuggestedFileName();
                    
                    // Use custom name if available for better file naming
                    const displayName = customAccountNames[account.id] || account.name;
                    if (customAccountNames[account.id]) {
                        // Replace the account name in the filename with custom name
                        const bankName = account.bankInfo?.orgName?.replace(/[^a-zA-Z0-9]/g, '').substring(0, 10) || 'Bank';
                        const accountType = account.type === 'BANK' ? 'checking' : 'cc';
                        const accountSuffix = account.number ? `-${account.number.slice(-4)}` : '';
                        const customNameSuffix = displayName.replace(/[^a-zA-Z0-9]/g, '').substring(0, 15);
                        
                        const startDateStr = dateStart.toISOString().split('T')[0].replace(/-/g, '');
                        const endDateStr = dateEnd.toISOString().split('T')[0].replace(/-/g, '');
                        
                        fileName = `${bankName}-${accountType}${accountSuffix}-${customNameSuffix}-${startDateStr}-${endDateStr}.ofx`;
                    }
                    
                    // Apply custom naming
                    if (prefix) {
                        fileName = `${prefix}-${fileName}`;
                    }
                    if (suffix) {
                        fileName = fileName.replace('.ofx', `-${suffix}.ofx`);
                    }

                    generatedFiles.push({
                        fileName,
                        content: ofxFile.output(),
                        accountName: displayName,
                        accountType: account.type
                    });
                }
            } catch (error) {
                console.error(`Error processing account ${account.id} (${account.name}):`, error);
                console.error(`Error details:`, error.message);
                // Continue with other accounts
            }
        }

        console.log(`Total files generated: ${generatedFiles.length}`);
        
        if (generatedFiles.length === 0) {
            return res.status(400).json({
                success: false,
                message: 'No OFX files were generated. This could be due to no transactions in the selected date range or account processing errors.'
            });
        }

        res.json({
            success: true,
            message: `Successfully generated ${generatedFiles.length} OFX files`,
            files: generatedFiles
        });

    } catch (error) {
        console.error('Export error:', error);
        res.status(500).json({
            success: false,
            message: `Export failed: ${error.message}`
        });
    }
});

// Download individual file
app.get('/api/download/:filename', async (req, res) => {
    try {
        const { filename } = req.params;
        // This would need to be implemented based on your file storage strategy
        res.status(501).json({
            success: false,
            message: 'Individual file download not yet implemented'
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Download failed'
        });
    }
});

// Create and download ZIP file
app.post('/api/export/zip', async (req, res) => {
    try {
        const { files } = req.body;

        console.log('ZIP request received with', files?.length || 0, 'files');
        console.log('Request body:', JSON.stringify(req.body, null, 2));

        if (!files || files.length === 0) {
            console.log('No files provided for ZIP creation');
            return res.status(400).json({
                success: false,
                message: 'No files provided for ZIP creation'
            });
        }

        // Set headers for ZIP download
        res.setHeader('Content-Type', 'application/zip');
        res.setHeader('Content-Disposition', `attachment; filename="OFX-Export-${new Date().toISOString().split('T')[0]}.zip"`);

        // Create ZIP archive
        const archive = archiver('zip', {
            zlib: { level: 9 } // Maximum compression
        });

        // Handle archive errors
        archive.on('error', (err) => {
            console.error('Archive error:', err);
            if (!res.headersSent) {
                res.status(500).json({
                    success: false,
                    message: 'Failed to create ZIP file'
                });
            }
        });

        // Handle response errors
        res.on('error', (err) => {
            console.error('Response error:', err);
        });

        // Pipe archive to response
        archive.pipe(res);

        // Add each file to the archive
        files.forEach((file, index) => {
            console.log(`Adding file ${index + 1}/${files.length}: ${file.fileName}`);
            archive.append(file.content, { name: file.fileName });
        });

        // Finalize the archive
        console.log('Finalizing ZIP archive...');
        await archive.finalize();
        console.log('ZIP archive created successfully');

    } catch (error) {
        console.error('ZIP creation error:', error);
        if (!res.headersSent) {
            res.status(500).json({
                success: false,
                message: 'Failed to create ZIP file'
            });
        }
    }
});

// Serve the HTML interface
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'index.html'));
});

// Error handling middleware
app.use((error, req, res, next) => {
    console.error('Unhandled error:', error);
    res.status(500).json({
        success: false,
        message: 'Internal server error'
    });
});

// Start server
app.listen(PORT, () => {
    console.log(`🚀 Pluggy OFX Exporter server running on http://localhost:${PORT}`);
    console.log(`📁 Open your browser and navigate to the URL above to use the interface`);
});

module.exports = app;
